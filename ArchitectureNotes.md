# Architecture Notes:

The game is composed by 2 executables:
- client (a.k.a. **Game**, one per player, connects to the server)
- **Server** (one instance, serves all the clients)

Both client and server executables links to a common **Shared** lib.
The Shared lib is mainly composed by constants, e.g. Gameplay constants
(max health, respawn time, etc), Server constants (port),
Network message ids, etc. In addition all these constants are
wrapped with macros to make them accessible using Angelscript (see Constants.cpp).

It looks like the core of the game is done on the Server.
I.e. the client seems to be a "simpler" interface used mainly to setup connection
to the server.
The server is the one creating the **SCENE** and sending it to the client during game initialization.
See the code below, which comes from the PlayersManager class of the server:
```
PlayersManager::OnClientConnected
	Urho3D::Scene *scene = context_->GetSubsystem <Urho3D::Scene> ();
    assert (scene);
    /// Assign scene. From the server, send scene to the client.
	/// This will cause the client to load it.
    connection->SetScene (scene);
```
Movements, fire etc, will be sent from client to server as a message.
The message will trigger the server that will react updating the nodes.
For example, physics will be calculated on the server, then the game **SCENE** is shared / replicated
from the client using a globally shared object, namely SharedGlobals::syncedGameScene in Ingame/LocalSceneManager.as

See the [Network](https://urho3d.io/documentation/1.5/_network.html) documentation to understand how **SCENE** screening is done.

## Client

The main is implemented in src/Game/Launcher.[h|c]pp (*Launcher class*).
Note that the Launcher class is just a wrapper around *AngelScript/GameApplication.as*,
where the real top level logic is implemented (e.g. Setup, Update, etc).

### sources/Game/Launcher (Launcher class):

- implements the classic Setup, Start, Update and Stop needed for the **GAME LOOP**
- Setup: initialize engine, ui, etc
- Start: initialize input (mouse), initialize angelscript engine, and load the **AngelScript/GameApplication.as** script, where the Setup, Start, Update and Stop are implemented
- Update: **AngelScript/GameApplication.as** is executed with new params on each **GAME LOOP**
- uses some of the src/Shared/Constants.[h|c]pp

### bin/Data/AngelScript/GameApplication.as

- Start: Initialize SharedGlobals (syncedGameScene, lastNickname) and initialize GameStateSwitcher, which starts by default to use LogInToServer/StateAdapter.as
- Update: run GameStatesSwitcher::UpdateState
- Stop: run GameStatesSwitcher::DisposeCurrentState
- HandleEvent: run GameStatesSwitcher::SendEventToCurrentState

Other angelscripts included by GameApplication.as:

- GameStatesSwitcher.as (updates and keep track of **GAME STATE** using an object implemementing the **GameStateAdapter** interface, i.e. LogInToServer/StateAdapter.as during login, which will then pass the control to Ingame/StateAdapter.as once the connection to the server is successful and the game starts)
- Sharedglobals.as (contains shared vars, e.g. **Scene @syncedGameScene**)
- LogInToServer/StateAdapter.as (implements the **GameStateAdapter**)
  - LogInToServer/StateUi.as (used by LogInToServer/StateAdapter.as)
- Ingame/StateAdapter.as (implements the **GameStateAdapter**)
  - Ingame/LocalSceneManager.as (uses the shared **Scene @syncedGameScene** to manage locally a "copy" of the **SCENE** which is generated by and handled by the server. During the Update, it loads **NODES** from bin/Data/Objects/*xml, e.g. obstacle\_local.xml, player\_local.xml, and it scans for other players etc.)
  - Ingame/NetworkHandler.as (SEND move request, fire request, and handle server messages. These requests are handled in server PlayerManager class, which update the server PlayerState, i.e. the **NODE** representing the player in the shared scene)
  - Ingame/StateUi.as (used by LogInToServer/StateAdapter.as)
  - Ingame/KeyboardListener.as
  - Ingame/UiListener.as

## Server

The main is implemented in sources/Server/Urho3DApplication.

### sources/Server/Urho3DApplication

- implements the classic Setup, Start, and Stop needed for the **GAME LOOP**
- Setup: initialize engine parameters
- Start: initialize input (mouse), initialize angelscript engine, add *Spawner* to **generate SCENE**, setup *PlayersManager*, starts Urho3D::Network
- Stop: stops Urho3D::Network, clear scene

NOTE: Update is missing! However, an Update method is available for the *PlayersManager* object, and that method is registered to run at each loop:
```
SubscribeToEvent (Urho3D::E_UPDATE, URHO3D_HANDLER (PlayersManager, Update));
```

### sources/Server/Spawner

Provides methods such as GenerateServerScene, used by Server/Urho3DApplication to initialize **SCENE** (load xmls, etc.).
Loads ServerCommandUi.as, which takes the inizialized **SCENE** and configure it (config camera, add nodes, etc) for the "login to server" UI.

### sources/Server/PlayersManager

An Urho3D::Object handling all players (human or ai). Is dependent on:

- PlayerState: handle the node representing a player (update health, remove nodes representing dead players, etc)
- AiPlayerState: derived by PlayerState, handles the node representing an ai player with the help of an as script

## Build info

- /bin/CoreData is copied from Urho3D engine.
- /bin/Data is created by the game developer (me) with data for this specific game:
  - AngelScript: contains .as scripts
  - Fonts: fonts files in .tff format. Referred by UI (see below)
  - Materials: Material and Technique resources define how to render 3D scene geometry. On the disk, they are XML or JSON data. A material defines the textures, shader parameters and culling & fill mode to use, and refers to one or several techniques. A technique defines the actual rendering passes, the shaders to use in each, and all other rendering states such as depth test, depth write, and blending.
  - Models: generated by tools such as Blender, exported to .mdl format. Can be opened in Urho editor.
  - Objects: **NODES** of the **SCENE** in xml format. Each object (node) is composed by Material, Model, Particles effect etc. Note that the scene can be created in code and exported to xml for editing.
  - Particles: effects, used in objects
  - Textures: textures in png or other formats, to be used in the UI
  - UI: put togheter Fonts, Textures, etc and is loaded by StateUI.as script (both LogInToServer and Ingame)

# Other

- Other material https://gitlab.com/game-engine-tutorials/urho3d-tutorials
